using System;
using System.Collections;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Waher.Persistence.Files.Storage
{
	/// <summary>
	/// Class that generates sequential, albeit cyclical, GUIDs for use in databases. They are not guaranteed to be
	/// globally unique. They are however unique to a very high degree of probability.
	/// </summary>
	public class SequentialGuidGenerator : IDisposable
	{
		private static DateTime reference = new DateTime(2000, 1, 1, 0, 0, 0, DateTimeKind.Utc);

		private RNGCryptoServiceProvider gen;
		private byte[] processId;
		private byte[] machineNr;
		private byte[] random;
		private uint counter;
		private bool reverseOrder;

		/// <summary>
		/// Class that generates sequential, albeit cyclical, GUIDs for use in databases. They are not guaranteed to be
		/// globally unique. They are however unique to a very high degree of probability.
		/// </summary>
		public SequentialGuidGenerator()
		{
			StringBuilder sb = new StringBuilder();

			sb.Append(Environment.MachineName);

			string MachineName = Environment.MachineName;

			foreach (DictionaryEntry Entry in Environment.GetEnvironmentVariables())
			{
				sb.Append(Entry.Key.ToString());
				sb.Append(Entry.Value.ToString());
			}

			using (SHA1Managed Sha1 = new SHA1Managed())
			{
				string MachineData = sb.ToString();
				byte[] Hash = Sha1.ComputeHash(Encoding.UTF8.GetBytes(MachineData));
				this.machineNr = new byte[3];
				Array.Copy(Hash, 0, this.machineNr, 0, 3);
			}

			this.gen = new RNGCryptoServiceProvider();
			this.processId = BitConverter.GetBytes((ushort)(System.Diagnostics.Process.GetCurrentProcess().Id));
			this.random = new byte[3];

			byte[] b = new byte[4];
			this.gen.GetBytes(b);
			this.counter = BitConverter.ToUInt32(b, 0);
			this.reverseOrder = !BitConverter.IsLittleEndian;
		}

		/// <summary>
		/// GUIDs are generated by sets of 16 bytes, that are defined as follows:
		/// 
		/// Bytes 0-3:		Number of seconds, since 2001-01-01. (Will wrap 2136-02-07, 06:28:16)
		/// Bytes 4-7:		Counter, started at a random number.
		/// Bytes 8-9:		Process ID.
		/// Bytes 10-12:	Machine number.
		/// Bytes 13-15:	Random number.
		/// </summary>
		/// <returns>New GUID</returns>
		public Guid CreateGuid()
		{
			byte[] b = new byte[16];
			uint Ticks = (uint)(DateTime.Now.ToUniversalTime() - reference).TotalSeconds;
			byte[] Buf;

			lock (this.gen)
			{
				this.gen.GetBytes(this.random);

				Buf = BitConverter.GetBytes(Ticks);
				if (this.reverseOrder)
					Array.Reverse(Buf);
				Array.Copy(Buf, 0, b, 0, 4);

				Buf = BitConverter.GetBytes(this.counter++);
				if (this.reverseOrder)
					Array.Reverse(Buf);

				b[4] = Buf[2];
				b[5] = Buf[3];
				b[6] = Buf[0];
				b[7] = Buf[1];

				Array.Copy(this.processId, 0, b, 8, 2);
				Array.Copy(this.machineNr, 0, b, 10, 3);
				Array.Copy(this.random, 0, b, 13, 3);
			}

			return new Guid(b);
		}

		/// <summary>
		/// <see cref="IDisposable.Dispose"/>
		/// </summary>
		public void Dispose()
		{
			if (this.gen != null)
			{
				this.gen.Dispose();
				this.gen = null;
			}
		}
	}
}
